// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_applications

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ApplicationsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"applications": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"base_directory": schema.StringAttribute{
							Computed:            true,
							Description:         "Base directory for all commands.",
							MarkdownDescription: "Base directory for all commands.",
						},
						"build_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Build command.",
							MarkdownDescription: "Build command.",
						},
						"build_pack": schema.StringAttribute{
							Computed:            true,
							Description:         "Build pack.",
							MarkdownDescription: "Build pack.",
						},
						"compose_parsing_version": schema.StringAttribute{
							Computed:            true,
							Description:         "How Coolify parse the compose file.",
							MarkdownDescription: "How Coolify parse the compose file.",
						},
						"config_hash": schema.StringAttribute{
							Computed:            true,
							Description:         "Configuration hash.",
							MarkdownDescription: "Configuration hash.",
						},
						"created_at": schema.StringAttribute{
							Computed:            true,
							Description:         "The date and time when the application was created.",
							MarkdownDescription: "The date and time when the application was created.",
						},
						"custom_docker_run_options": schema.StringAttribute{
							Computed:            true,
							Description:         "Custom docker run options.",
							MarkdownDescription: "Custom docker run options.",
						},
						"custom_healthcheck_found": schema.BoolAttribute{
							Computed:            true,
							Description:         "Custom healthcheck found.",
							MarkdownDescription: "Custom healthcheck found.",
						},
						"custom_labels": schema.StringAttribute{
							Computed:            true,
							Description:         "Custom labels.",
							MarkdownDescription: "Custom labels.",
						},
						"custom_nginx_configuration": schema.StringAttribute{
							Computed:            true,
							Description:         "Custom Nginx configuration base64 encoded.",
							MarkdownDescription: "Custom Nginx configuration base64 encoded.",
						},
						"deleted_at": schema.StringAttribute{
							Computed:            true,
							Description:         "The date and time when the application was deleted.",
							MarkdownDescription: "The date and time when the application was deleted.",
						},
						"description": schema.StringAttribute{
							Computed:            true,
							Description:         "The application description.",
							MarkdownDescription: "The application description.",
						},
						"destination_id": schema.Int64Attribute{
							Computed:            true,
							Description:         "Destination identifier.",
							MarkdownDescription: "Destination identifier.",
						},
						"destination_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Destination type.",
							MarkdownDescription: "Destination type.",
						},
						"docker_compose": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker compose content. Used for docker compose build pack.",
							MarkdownDescription: "Docker compose content. Used for docker compose build pack.",
						},
						"docker_compose_custom_build_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker compose custom build command.",
							MarkdownDescription: "Docker compose custom build command.",
						},
						"docker_compose_custom_start_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker compose custom start command.",
							MarkdownDescription: "Docker compose custom start command.",
						},
						"docker_compose_domains": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker compose domains.",
							MarkdownDescription: "Docker compose domains.",
						},
						"docker_compose_location": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker compose location.",
							MarkdownDescription: "Docker compose location.",
						},
						"docker_compose_raw": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker compose raw content.",
							MarkdownDescription: "Docker compose raw content.",
						},
						"docker_registry_image_name": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker registry image name.",
							MarkdownDescription: "Docker registry image name.",
						},
						"docker_registry_image_tag": schema.StringAttribute{
							Computed:            true,
							Description:         "Docker registry image tag.",
							MarkdownDescription: "Docker registry image tag.",
						},
						"dockerfile": schema.StringAttribute{
							Computed:            true,
							Description:         "Dockerfile content. Used for dockerfile build pack.",
							MarkdownDescription: "Dockerfile content. Used for dockerfile build pack.",
						},
						"dockerfile_location": schema.StringAttribute{
							Computed:            true,
							Description:         "Dockerfile location.",
							MarkdownDescription: "Dockerfile location.",
						},
						"dockerfile_target_build": schema.StringAttribute{
							Computed:            true,
							Description:         "Dockerfile target build.",
							MarkdownDescription: "Dockerfile target build.",
						},
						"environment_id": schema.Int64Attribute{
							Computed:            true,
							Description:         "Environment identifier.",
							MarkdownDescription: "Environment identifier.",
						},
						"fqdn": schema.StringAttribute{
							Computed:            true,
							Description:         "The application domains.",
							MarkdownDescription: "The application domains.",
						},
						"git_branch": schema.StringAttribute{
							Computed:            true,
							Description:         "Git branch.",
							MarkdownDescription: "Git branch.",
						},
						"git_commit_sha": schema.StringAttribute{
							Computed:            true,
							Description:         "Git commit SHA.",
							MarkdownDescription: "Git commit SHA.",
						},
						"git_full_url": schema.StringAttribute{
							Computed:            true,
							Description:         "Git full URL.",
							MarkdownDescription: "Git full URL.",
						},
						"git_repository": schema.StringAttribute{
							Computed:            true,
							Description:         "Git repository URL.",
							MarkdownDescription: "Git repository URL.",
						},
						"health_check_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Health check enabled.",
							MarkdownDescription: "Health check enabled.",
						},
						"health_check_host": schema.StringAttribute{
							Computed:            true,
							Description:         "Health check host.",
							MarkdownDescription: "Health check host.",
						},
						"health_check_interval": schema.Int64Attribute{
							Computed:            true,
							Description:         "Health check interval in seconds.",
							MarkdownDescription: "Health check interval in seconds.",
						},
						"health_check_method": schema.StringAttribute{
							Computed:            true,
							Description:         "Health check method.",
							MarkdownDescription: "Health check method.",
						},
						"health_check_path": schema.StringAttribute{
							Computed:            true,
							Description:         "Health check path.",
							MarkdownDescription: "Health check path.",
						},
						"health_check_port": schema.StringAttribute{
							Computed:            true,
							Description:         "Health check port.",
							MarkdownDescription: "Health check port.",
						},
						"health_check_response_text": schema.StringAttribute{
							Computed:            true,
							Description:         "Health check response text.",
							MarkdownDescription: "Health check response text.",
						},
						"health_check_retries": schema.Int64Attribute{
							Computed:            true,
							Description:         "Health check retries count.",
							MarkdownDescription: "Health check retries count.",
						},
						"health_check_return_code": schema.Int64Attribute{
							Computed:            true,
							Description:         "Health check return code.",
							MarkdownDescription: "Health check return code.",
						},
						"health_check_scheme": schema.StringAttribute{
							Computed:            true,
							Description:         "Health check scheme.",
							MarkdownDescription: "Health check scheme.",
						},
						"health_check_start_period": schema.Int64Attribute{
							Computed:            true,
							Description:         "Health check start period in seconds.",
							MarkdownDescription: "Health check start period in seconds.",
						},
						"health_check_timeout": schema.Int64Attribute{
							Computed:            true,
							Description:         "Health check timeout in seconds.",
							MarkdownDescription: "Health check timeout in seconds.",
						},
						"id": schema.Int64Attribute{
							Computed:            true,
							Description:         "The application identifier in the database.",
							MarkdownDescription: "The application identifier in the database.",
						},
						"install_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Install command.",
							MarkdownDescription: "Install command.",
						},
						"limits_cpu_shares": schema.Int64Attribute{
							Computed:            true,
							Description:         "CPU shares.",
							MarkdownDescription: "CPU shares.",
						},
						"limits_cpus": schema.StringAttribute{
							Computed:            true,
							Description:         "CPU limit.",
							MarkdownDescription: "CPU limit.",
						},
						"limits_cpuset": schema.StringAttribute{
							Computed:            true,
							Description:         "CPU set.",
							MarkdownDescription: "CPU set.",
						},
						"limits_memory": schema.StringAttribute{
							Computed:            true,
							Description:         "Memory limit.",
							MarkdownDescription: "Memory limit.",
						},
						"limits_memory_reservation": schema.StringAttribute{
							Computed:            true,
							Description:         "Memory reservation.",
							MarkdownDescription: "Memory reservation.",
						},
						"limits_memory_swap": schema.StringAttribute{
							Computed:            true,
							Description:         "Memory swap limit.",
							MarkdownDescription: "Memory swap limit.",
						},
						"limits_memory_swappiness": schema.Int64Attribute{
							Computed:            true,
							Description:         "Memory swappiness.",
							MarkdownDescription: "Memory swappiness.",
						},
						"manual_webhook_secret_bitbucket": schema.StringAttribute{
							Computed:            true,
							Description:         "Manual webhook secret for Bitbucket.",
							MarkdownDescription: "Manual webhook secret for Bitbucket.",
						},
						"manual_webhook_secret_gitea": schema.StringAttribute{
							Computed:            true,
							Description:         "Manual webhook secret for Gitea.",
							MarkdownDescription: "Manual webhook secret for Gitea.",
						},
						"manual_webhook_secret_github": schema.StringAttribute{
							Computed:            true,
							Description:         "Manual webhook secret for GitHub.",
							MarkdownDescription: "Manual webhook secret for GitHub.",
						},
						"manual_webhook_secret_gitlab": schema.StringAttribute{
							Computed:            true,
							Description:         "Manual webhook secret for GitLab.",
							MarkdownDescription: "Manual webhook secret for GitLab.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "The application name.",
							MarkdownDescription: "The application name.",
						},
						"ports_exposes": schema.StringAttribute{
							Computed:            true,
							Description:         "Ports exposes.",
							MarkdownDescription: "Ports exposes.",
						},
						"ports_mappings": schema.StringAttribute{
							Computed:            true,
							Description:         "Ports mappings.",
							MarkdownDescription: "Ports mappings.",
						},
						"post_deployment_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Post deployment command.",
							MarkdownDescription: "Post deployment command.",
						},
						"post_deployment_command_container": schema.StringAttribute{
							Computed:            true,
							Description:         "Post deployment command container.",
							MarkdownDescription: "Post deployment command container.",
						},
						"pre_deployment_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Pre deployment command.",
							MarkdownDescription: "Pre deployment command.",
						},
						"pre_deployment_command_container": schema.StringAttribute{
							Computed:            true,
							Description:         "Pre deployment command container.",
							MarkdownDescription: "Pre deployment command container.",
						},
						"preview_url_template": schema.StringAttribute{
							Computed:            true,
							Description:         "Preview URL template.",
							MarkdownDescription: "Preview URL template.",
						},
						"private_key_id": schema.Int64Attribute{
							Computed:            true,
							Description:         "Private key identifier.",
							MarkdownDescription: "Private key identifier.",
						},
						"publish_directory": schema.StringAttribute{
							Computed:            true,
							Description:         "Publish directory.",
							MarkdownDescription: "Publish directory.",
						},
						"redirect": schema.StringAttribute{
							Computed:            true,
							Description:         "How to set redirect with Traefik / Caddy. www<->non-www.",
							MarkdownDescription: "How to set redirect with Traefik / Caddy. www<->non-www.",
						},
						"repository_project_id": schema.Int64Attribute{
							Computed:            true,
							Description:         "The repository project identifier.",
							MarkdownDescription: "The repository project identifier.",
						},
						"source_id": schema.Int64Attribute{
							Computed:            true,
							Description:         "Source identifier.",
							MarkdownDescription: "Source identifier.",
						},
						"start_command": schema.StringAttribute{
							Computed:            true,
							Description:         "Start command.",
							MarkdownDescription: "Start command.",
						},
						"static_image": schema.StringAttribute{
							Computed:            true,
							Description:         "Static image used when static site is deployed.",
							MarkdownDescription: "Static image used when static site is deployed.",
						},
						"status": schema.StringAttribute{
							Computed:            true,
							Description:         "Application status.",
							MarkdownDescription: "Application status.",
						},
						"swarm_placement_constraints": schema.StringAttribute{
							Computed:            true,
							Description:         "Swarm placement constraints. Only used for swarm deployments.",
							MarkdownDescription: "Swarm placement constraints. Only used for swarm deployments.",
						},
						"swarm_replicas": schema.Int64Attribute{
							Computed:            true,
							Description:         "Swarm replicas. Only used for swarm deployments.",
							MarkdownDescription: "Swarm replicas. Only used for swarm deployments.",
						},
						"updated_at": schema.StringAttribute{
							Computed:            true,
							Description:         "The date and time when the application was last updated.",
							MarkdownDescription: "The date and time when the application was last updated.",
						},
						"uuid": schema.StringAttribute{
							Computed:            true,
							Description:         "The application UUID.",
							MarkdownDescription: "The application UUID.",
						},
						"watch_paths": schema.StringAttribute{
							Computed:            true,
							Description:         "Watch paths.",
							MarkdownDescription: "Watch paths.",
						},
					},
					CustomType: ApplicationsType{
						ObjectType: types.ObjectType{
							AttrTypes: ApplicationsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type ApplicationsModel struct {
	Applications types.Set `tfsdk:"applications"`
}

var _ basetypes.ObjectTypable = ApplicationsType{}

type ApplicationsType struct {
	basetypes.ObjectType
}

func (t ApplicationsType) Equal(o attr.Type) bool {
	other, ok := o.(ApplicationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApplicationsType) String() string {
	return "ApplicationsType"
}

func (t ApplicationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	baseDirectoryAttribute, ok := attributes["base_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base_directory is missing from object`)

		return nil, diags
	}

	baseDirectoryVal, ok := baseDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base_directory expected to be basetypes.StringValue, was: %T`, baseDirectoryAttribute))
	}

	buildCommandAttribute, ok := attributes["build_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`build_command is missing from object`)

		return nil, diags
	}

	buildCommandVal, ok := buildCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`build_command expected to be basetypes.StringValue, was: %T`, buildCommandAttribute))
	}

	buildPackAttribute, ok := attributes["build_pack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`build_pack is missing from object`)

		return nil, diags
	}

	buildPackVal, ok := buildPackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`build_pack expected to be basetypes.StringValue, was: %T`, buildPackAttribute))
	}

	composeParsingVersionAttribute, ok := attributes["compose_parsing_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`compose_parsing_version is missing from object`)

		return nil, diags
	}

	composeParsingVersionVal, ok := composeParsingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`compose_parsing_version expected to be basetypes.StringValue, was: %T`, composeParsingVersionAttribute))
	}

	configHashAttribute, ok := attributes["config_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_hash is missing from object`)

		return nil, diags
	}

	configHashVal, ok := configHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_hash expected to be basetypes.StringValue, was: %T`, configHashAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	customDockerRunOptionsAttribute, ok := attributes["custom_docker_run_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_docker_run_options is missing from object`)

		return nil, diags
	}

	customDockerRunOptionsVal, ok := customDockerRunOptionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_docker_run_options expected to be basetypes.StringValue, was: %T`, customDockerRunOptionsAttribute))
	}

	customHealthcheckFoundAttribute, ok := attributes["custom_healthcheck_found"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_healthcheck_found is missing from object`)

		return nil, diags
	}

	customHealthcheckFoundVal, ok := customHealthcheckFoundAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_healthcheck_found expected to be basetypes.BoolValue, was: %T`, customHealthcheckFoundAttribute))
	}

	customLabelsAttribute, ok := attributes["custom_labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_labels is missing from object`)

		return nil, diags
	}

	customLabelsVal, ok := customLabelsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_labels expected to be basetypes.StringValue, was: %T`, customLabelsAttribute))
	}

	customNginxConfigurationAttribute, ok := attributes["custom_nginx_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_nginx_configuration is missing from object`)

		return nil, diags
	}

	customNginxConfigurationVal, ok := customNginxConfigurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_nginx_configuration expected to be basetypes.StringValue, was: %T`, customNginxConfigurationAttribute))
	}

	deletedAtAttribute, ok := attributes["deleted_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted_at is missing from object`)

		return nil, diags
	}

	deletedAtVal, ok := deletedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted_at expected to be basetypes.StringValue, was: %T`, deletedAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	destinationIdAttribute, ok := attributes["destination_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_id is missing from object`)

		return nil, diags
	}

	destinationIdVal, ok := destinationIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_id expected to be basetypes.Int64Value, was: %T`, destinationIdAttribute))
	}

	destinationTypeAttribute, ok := attributes["destination_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_type is missing from object`)

		return nil, diags
	}

	destinationTypeVal, ok := destinationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_type expected to be basetypes.StringValue, was: %T`, destinationTypeAttribute))
	}

	dockerComposeAttribute, ok := attributes["docker_compose"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose is missing from object`)

		return nil, diags
	}

	dockerComposeVal, ok := dockerComposeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose expected to be basetypes.StringValue, was: %T`, dockerComposeAttribute))
	}

	dockerComposeCustomBuildCommandAttribute, ok := attributes["docker_compose_custom_build_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_custom_build_command is missing from object`)

		return nil, diags
	}

	dockerComposeCustomBuildCommandVal, ok := dockerComposeCustomBuildCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_custom_build_command expected to be basetypes.StringValue, was: %T`, dockerComposeCustomBuildCommandAttribute))
	}

	dockerComposeCustomStartCommandAttribute, ok := attributes["docker_compose_custom_start_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_custom_start_command is missing from object`)

		return nil, diags
	}

	dockerComposeCustomStartCommandVal, ok := dockerComposeCustomStartCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_custom_start_command expected to be basetypes.StringValue, was: %T`, dockerComposeCustomStartCommandAttribute))
	}

	dockerComposeDomainsAttribute, ok := attributes["docker_compose_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_domains is missing from object`)

		return nil, diags
	}

	dockerComposeDomainsVal, ok := dockerComposeDomainsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_domains expected to be basetypes.StringValue, was: %T`, dockerComposeDomainsAttribute))
	}

	dockerComposeLocationAttribute, ok := attributes["docker_compose_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_location is missing from object`)

		return nil, diags
	}

	dockerComposeLocationVal, ok := dockerComposeLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_location expected to be basetypes.StringValue, was: %T`, dockerComposeLocationAttribute))
	}

	dockerComposeRawAttribute, ok := attributes["docker_compose_raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_raw is missing from object`)

		return nil, diags
	}

	dockerComposeRawVal, ok := dockerComposeRawAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_raw expected to be basetypes.StringValue, was: %T`, dockerComposeRawAttribute))
	}

	dockerRegistryImageNameAttribute, ok := attributes["docker_registry_image_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_registry_image_name is missing from object`)

		return nil, diags
	}

	dockerRegistryImageNameVal, ok := dockerRegistryImageNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_registry_image_name expected to be basetypes.StringValue, was: %T`, dockerRegistryImageNameAttribute))
	}

	dockerRegistryImageTagAttribute, ok := attributes["docker_registry_image_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_registry_image_tag is missing from object`)

		return nil, diags
	}

	dockerRegistryImageTagVal, ok := dockerRegistryImageTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_registry_image_tag expected to be basetypes.StringValue, was: %T`, dockerRegistryImageTagAttribute))
	}

	dockerfileAttribute, ok := attributes["dockerfile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dockerfile is missing from object`)

		return nil, diags
	}

	dockerfileVal, ok := dockerfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dockerfile expected to be basetypes.StringValue, was: %T`, dockerfileAttribute))
	}

	dockerfileLocationAttribute, ok := attributes["dockerfile_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dockerfile_location is missing from object`)

		return nil, diags
	}

	dockerfileLocationVal, ok := dockerfileLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dockerfile_location expected to be basetypes.StringValue, was: %T`, dockerfileLocationAttribute))
	}

	dockerfileTargetBuildAttribute, ok := attributes["dockerfile_target_build"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dockerfile_target_build is missing from object`)

		return nil, diags
	}

	dockerfileTargetBuildVal, ok := dockerfileTargetBuildAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dockerfile_target_build expected to be basetypes.StringValue, was: %T`, dockerfileTargetBuildAttribute))
	}

	environmentIdAttribute, ok := attributes["environment_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`environment_id is missing from object`)

		return nil, diags
	}

	environmentIdVal, ok := environmentIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`environment_id expected to be basetypes.Int64Value, was: %T`, environmentIdAttribute))
	}

	fqdnAttribute, ok := attributes["fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fqdn is missing from object`)

		return nil, diags
	}

	fqdnVal, ok := fqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fqdn expected to be basetypes.StringValue, was: %T`, fqdnAttribute))
	}

	gitBranchAttribute, ok := attributes["git_branch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_branch is missing from object`)

		return nil, diags
	}

	gitBranchVal, ok := gitBranchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_branch expected to be basetypes.StringValue, was: %T`, gitBranchAttribute))
	}

	gitCommitShaAttribute, ok := attributes["git_commit_sha"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_commit_sha is missing from object`)

		return nil, diags
	}

	gitCommitShaVal, ok := gitCommitShaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_commit_sha expected to be basetypes.StringValue, was: %T`, gitCommitShaAttribute))
	}

	gitFullUrlAttribute, ok := attributes["git_full_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_full_url is missing from object`)

		return nil, diags
	}

	gitFullUrlVal, ok := gitFullUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_full_url expected to be basetypes.StringValue, was: %T`, gitFullUrlAttribute))
	}

	gitRepositoryAttribute, ok := attributes["git_repository"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_repository is missing from object`)

		return nil, diags
	}

	gitRepositoryVal, ok := gitRepositoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_repository expected to be basetypes.StringValue, was: %T`, gitRepositoryAttribute))
	}

	healthCheckEnabledAttribute, ok := attributes["health_check_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_enabled is missing from object`)

		return nil, diags
	}

	healthCheckEnabledVal, ok := healthCheckEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_enabled expected to be basetypes.BoolValue, was: %T`, healthCheckEnabledAttribute))
	}

	healthCheckHostAttribute, ok := attributes["health_check_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_host is missing from object`)

		return nil, diags
	}

	healthCheckHostVal, ok := healthCheckHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_host expected to be basetypes.StringValue, was: %T`, healthCheckHostAttribute))
	}

	healthCheckIntervalAttribute, ok := attributes["health_check_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_interval is missing from object`)

		return nil, diags
	}

	healthCheckIntervalVal, ok := healthCheckIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_interval expected to be basetypes.Int64Value, was: %T`, healthCheckIntervalAttribute))
	}

	healthCheckMethodAttribute, ok := attributes["health_check_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_method is missing from object`)

		return nil, diags
	}

	healthCheckMethodVal, ok := healthCheckMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_method expected to be basetypes.StringValue, was: %T`, healthCheckMethodAttribute))
	}

	healthCheckPathAttribute, ok := attributes["health_check_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_path is missing from object`)

		return nil, diags
	}

	healthCheckPathVal, ok := healthCheckPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_path expected to be basetypes.StringValue, was: %T`, healthCheckPathAttribute))
	}

	healthCheckPortAttribute, ok := attributes["health_check_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_port is missing from object`)

		return nil, diags
	}

	healthCheckPortVal, ok := healthCheckPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_port expected to be basetypes.StringValue, was: %T`, healthCheckPortAttribute))
	}

	healthCheckResponseTextAttribute, ok := attributes["health_check_response_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_response_text is missing from object`)

		return nil, diags
	}

	healthCheckResponseTextVal, ok := healthCheckResponseTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_response_text expected to be basetypes.StringValue, was: %T`, healthCheckResponseTextAttribute))
	}

	healthCheckRetriesAttribute, ok := attributes["health_check_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_retries is missing from object`)

		return nil, diags
	}

	healthCheckRetriesVal, ok := healthCheckRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_retries expected to be basetypes.Int64Value, was: %T`, healthCheckRetriesAttribute))
	}

	healthCheckReturnCodeAttribute, ok := attributes["health_check_return_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_return_code is missing from object`)

		return nil, diags
	}

	healthCheckReturnCodeVal, ok := healthCheckReturnCodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_return_code expected to be basetypes.Int64Value, was: %T`, healthCheckReturnCodeAttribute))
	}

	healthCheckSchemeAttribute, ok := attributes["health_check_scheme"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_scheme is missing from object`)

		return nil, diags
	}

	healthCheckSchemeVal, ok := healthCheckSchemeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_scheme expected to be basetypes.StringValue, was: %T`, healthCheckSchemeAttribute))
	}

	healthCheckStartPeriodAttribute, ok := attributes["health_check_start_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_start_period is missing from object`)

		return nil, diags
	}

	healthCheckStartPeriodVal, ok := healthCheckStartPeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_start_period expected to be basetypes.Int64Value, was: %T`, healthCheckStartPeriodAttribute))
	}

	healthCheckTimeoutAttribute, ok := attributes["health_check_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_timeout is missing from object`)

		return nil, diags
	}

	healthCheckTimeoutVal, ok := healthCheckTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_timeout expected to be basetypes.Int64Value, was: %T`, healthCheckTimeoutAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	installCommandAttribute, ok := attributes["install_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`install_command is missing from object`)

		return nil, diags
	}

	installCommandVal, ok := installCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`install_command expected to be basetypes.StringValue, was: %T`, installCommandAttribute))
	}

	limitsCpuSharesAttribute, ok := attributes["limits_cpu_shares"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_cpu_shares is missing from object`)

		return nil, diags
	}

	limitsCpuSharesVal, ok := limitsCpuSharesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_cpu_shares expected to be basetypes.Int64Value, was: %T`, limitsCpuSharesAttribute))
	}

	limitsCpusAttribute, ok := attributes["limits_cpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_cpus is missing from object`)

		return nil, diags
	}

	limitsCpusVal, ok := limitsCpusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_cpus expected to be basetypes.StringValue, was: %T`, limitsCpusAttribute))
	}

	limitsCpusetAttribute, ok := attributes["limits_cpuset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_cpuset is missing from object`)

		return nil, diags
	}

	limitsCpusetVal, ok := limitsCpusetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_cpuset expected to be basetypes.StringValue, was: %T`, limitsCpusetAttribute))
	}

	limitsMemoryAttribute, ok := attributes["limits_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory is missing from object`)

		return nil, diags
	}

	limitsMemoryVal, ok := limitsMemoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory expected to be basetypes.StringValue, was: %T`, limitsMemoryAttribute))
	}

	limitsMemoryReservationAttribute, ok := attributes["limits_memory_reservation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory_reservation is missing from object`)

		return nil, diags
	}

	limitsMemoryReservationVal, ok := limitsMemoryReservationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory_reservation expected to be basetypes.StringValue, was: %T`, limitsMemoryReservationAttribute))
	}

	limitsMemorySwapAttribute, ok := attributes["limits_memory_swap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory_swap is missing from object`)

		return nil, diags
	}

	limitsMemorySwapVal, ok := limitsMemorySwapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory_swap expected to be basetypes.StringValue, was: %T`, limitsMemorySwapAttribute))
	}

	limitsMemorySwappinessAttribute, ok := attributes["limits_memory_swappiness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory_swappiness is missing from object`)

		return nil, diags
	}

	limitsMemorySwappinessVal, ok := limitsMemorySwappinessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory_swappiness expected to be basetypes.Int64Value, was: %T`, limitsMemorySwappinessAttribute))
	}

	manualWebhookSecretBitbucketAttribute, ok := attributes["manual_webhook_secret_bitbucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_bitbucket is missing from object`)

		return nil, diags
	}

	manualWebhookSecretBitbucketVal, ok := manualWebhookSecretBitbucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_bitbucket expected to be basetypes.StringValue, was: %T`, manualWebhookSecretBitbucketAttribute))
	}

	manualWebhookSecretGiteaAttribute, ok := attributes["manual_webhook_secret_gitea"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_gitea is missing from object`)

		return nil, diags
	}

	manualWebhookSecretGiteaVal, ok := manualWebhookSecretGiteaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_gitea expected to be basetypes.StringValue, was: %T`, manualWebhookSecretGiteaAttribute))
	}

	manualWebhookSecretGithubAttribute, ok := attributes["manual_webhook_secret_github"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_github is missing from object`)

		return nil, diags
	}

	manualWebhookSecretGithubVal, ok := manualWebhookSecretGithubAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_github expected to be basetypes.StringValue, was: %T`, manualWebhookSecretGithubAttribute))
	}

	manualWebhookSecretGitlabAttribute, ok := attributes["manual_webhook_secret_gitlab"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_gitlab is missing from object`)

		return nil, diags
	}

	manualWebhookSecretGitlabVal, ok := manualWebhookSecretGitlabAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_gitlab expected to be basetypes.StringValue, was: %T`, manualWebhookSecretGitlabAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portsExposesAttribute, ok := attributes["ports_exposes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports_exposes is missing from object`)

		return nil, diags
	}

	portsExposesVal, ok := portsExposesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports_exposes expected to be basetypes.StringValue, was: %T`, portsExposesAttribute))
	}

	portsMappingsAttribute, ok := attributes["ports_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports_mappings is missing from object`)

		return nil, diags
	}

	portsMappingsVal, ok := portsMappingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports_mappings expected to be basetypes.StringValue, was: %T`, portsMappingsAttribute))
	}

	postDeploymentCommandAttribute, ok := attributes["post_deployment_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`post_deployment_command is missing from object`)

		return nil, diags
	}

	postDeploymentCommandVal, ok := postDeploymentCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`post_deployment_command expected to be basetypes.StringValue, was: %T`, postDeploymentCommandAttribute))
	}

	postDeploymentCommandContainerAttribute, ok := attributes["post_deployment_command_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`post_deployment_command_container is missing from object`)

		return nil, diags
	}

	postDeploymentCommandContainerVal, ok := postDeploymentCommandContainerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`post_deployment_command_container expected to be basetypes.StringValue, was: %T`, postDeploymentCommandContainerAttribute))
	}

	preDeploymentCommandAttribute, ok := attributes["pre_deployment_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_deployment_command is missing from object`)

		return nil, diags
	}

	preDeploymentCommandVal, ok := preDeploymentCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_deployment_command expected to be basetypes.StringValue, was: %T`, preDeploymentCommandAttribute))
	}

	preDeploymentCommandContainerAttribute, ok := attributes["pre_deployment_command_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_deployment_command_container is missing from object`)

		return nil, diags
	}

	preDeploymentCommandContainerVal, ok := preDeploymentCommandContainerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_deployment_command_container expected to be basetypes.StringValue, was: %T`, preDeploymentCommandContainerAttribute))
	}

	previewUrlTemplateAttribute, ok := attributes["preview_url_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preview_url_template is missing from object`)

		return nil, diags
	}

	previewUrlTemplateVal, ok := previewUrlTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preview_url_template expected to be basetypes.StringValue, was: %T`, previewUrlTemplateAttribute))
	}

	privateKeyIdAttribute, ok := attributes["private_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key_id is missing from object`)

		return nil, diags
	}

	privateKeyIdVal, ok := privateKeyIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key_id expected to be basetypes.Int64Value, was: %T`, privateKeyIdAttribute))
	}

	publishDirectoryAttribute, ok := attributes["publish_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`publish_directory is missing from object`)

		return nil, diags
	}

	publishDirectoryVal, ok := publishDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`publish_directory expected to be basetypes.StringValue, was: %T`, publishDirectoryAttribute))
	}

	redirectAttribute, ok := attributes["redirect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redirect is missing from object`)

		return nil, diags
	}

	redirectVal, ok := redirectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redirect expected to be basetypes.StringValue, was: %T`, redirectAttribute))
	}

	repositoryProjectIdAttribute, ok := attributes["repository_project_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repository_project_id is missing from object`)

		return nil, diags
	}

	repositoryProjectIdVal, ok := repositoryProjectIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repository_project_id expected to be basetypes.Int64Value, was: %T`, repositoryProjectIdAttribute))
	}

	sourceIdAttribute, ok := attributes["source_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_id is missing from object`)

		return nil, diags
	}

	sourceIdVal, ok := sourceIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_id expected to be basetypes.Int64Value, was: %T`, sourceIdAttribute))
	}

	startCommandAttribute, ok := attributes["start_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_command is missing from object`)

		return nil, diags
	}

	startCommandVal, ok := startCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_command expected to be basetypes.StringValue, was: %T`, startCommandAttribute))
	}

	staticImageAttribute, ok := attributes["static_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_image is missing from object`)

		return nil, diags
	}

	staticImageVal, ok := staticImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_image expected to be basetypes.StringValue, was: %T`, staticImageAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	swarmPlacementConstraintsAttribute, ok := attributes["swarm_placement_constraints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`swarm_placement_constraints is missing from object`)

		return nil, diags
	}

	swarmPlacementConstraintsVal, ok := swarmPlacementConstraintsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`swarm_placement_constraints expected to be basetypes.StringValue, was: %T`, swarmPlacementConstraintsAttribute))
	}

	swarmReplicasAttribute, ok := attributes["swarm_replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`swarm_replicas is missing from object`)

		return nil, diags
	}

	swarmReplicasVal, ok := swarmReplicasAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`swarm_replicas expected to be basetypes.Int64Value, was: %T`, swarmReplicasAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	watchPathsAttribute, ok := attributes["watch_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`watch_paths is missing from object`)

		return nil, diags
	}

	watchPathsVal, ok := watchPathsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`watch_paths expected to be basetypes.StringValue, was: %T`, watchPathsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApplicationsValue{
		BaseDirectory:                   baseDirectoryVal,
		BuildCommand:                    buildCommandVal,
		BuildPack:                       buildPackVal,
		ComposeParsingVersion:           composeParsingVersionVal,
		ConfigHash:                      configHashVal,
		CreatedAt:                       createdAtVal,
		CustomDockerRunOptions:          customDockerRunOptionsVal,
		CustomHealthcheckFound:          customHealthcheckFoundVal,
		CustomLabels:                    customLabelsVal,
		CustomNginxConfiguration:        customNginxConfigurationVal,
		DeletedAt:                       deletedAtVal,
		Description:                     descriptionVal,
		DestinationId:                   destinationIdVal,
		DestinationType:                 destinationTypeVal,
		DockerCompose:                   dockerComposeVal,
		DockerComposeCustomBuildCommand: dockerComposeCustomBuildCommandVal,
		DockerComposeCustomStartCommand: dockerComposeCustomStartCommandVal,
		DockerComposeDomains:            dockerComposeDomainsVal,
		DockerComposeLocation:           dockerComposeLocationVal,
		DockerComposeRaw:                dockerComposeRawVal,
		DockerRegistryImageName:         dockerRegistryImageNameVal,
		DockerRegistryImageTag:          dockerRegistryImageTagVal,
		Dockerfile:                      dockerfileVal,
		DockerfileLocation:              dockerfileLocationVal,
		DockerfileTargetBuild:           dockerfileTargetBuildVal,
		EnvironmentId:                   environmentIdVal,
		Fqdn:                            fqdnVal,
		GitBranch:                       gitBranchVal,
		GitCommitSha:                    gitCommitShaVal,
		GitFullUrl:                      gitFullUrlVal,
		GitRepository:                   gitRepositoryVal,
		HealthCheckEnabled:              healthCheckEnabledVal,
		HealthCheckHost:                 healthCheckHostVal,
		HealthCheckInterval:             healthCheckIntervalVal,
		HealthCheckMethod:               healthCheckMethodVal,
		HealthCheckPath:                 healthCheckPathVal,
		HealthCheckPort:                 healthCheckPortVal,
		HealthCheckResponseText:         healthCheckResponseTextVal,
		HealthCheckRetries:              healthCheckRetriesVal,
		HealthCheckReturnCode:           healthCheckReturnCodeVal,
		HealthCheckScheme:               healthCheckSchemeVal,
		HealthCheckStartPeriod:          healthCheckStartPeriodVal,
		HealthCheckTimeout:              healthCheckTimeoutVal,
		Id:                              idVal,
		InstallCommand:                  installCommandVal,
		LimitsCpuShares:                 limitsCpuSharesVal,
		LimitsCpus:                      limitsCpusVal,
		LimitsCpuset:                    limitsCpusetVal,
		LimitsMemory:                    limitsMemoryVal,
		LimitsMemoryReservation:         limitsMemoryReservationVal,
		LimitsMemorySwap:                limitsMemorySwapVal,
		LimitsMemorySwappiness:          limitsMemorySwappinessVal,
		ManualWebhookSecretBitbucket:    manualWebhookSecretBitbucketVal,
		ManualWebhookSecretGitea:        manualWebhookSecretGiteaVal,
		ManualWebhookSecretGithub:       manualWebhookSecretGithubVal,
		ManualWebhookSecretGitlab:       manualWebhookSecretGitlabVal,
		Name:                            nameVal,
		PortsExposes:                    portsExposesVal,
		PortsMappings:                   portsMappingsVal,
		PostDeploymentCommand:           postDeploymentCommandVal,
		PostDeploymentCommandContainer:  postDeploymentCommandContainerVal,
		PreDeploymentCommand:            preDeploymentCommandVal,
		PreDeploymentCommandContainer:   preDeploymentCommandContainerVal,
		PreviewUrlTemplate:              previewUrlTemplateVal,
		PrivateKeyId:                    privateKeyIdVal,
		PublishDirectory:                publishDirectoryVal,
		Redirect:                        redirectVal,
		RepositoryProjectId:             repositoryProjectIdVal,
		SourceId:                        sourceIdVal,
		StartCommand:                    startCommandVal,
		StaticImage:                     staticImageVal,
		Status:                          statusVal,
		SwarmPlacementConstraints:       swarmPlacementConstraintsVal,
		SwarmReplicas:                   swarmReplicasVal,
		UpdatedAt:                       updatedAtVal,
		Uuid:                            uuidVal,
		WatchPaths:                      watchPathsVal,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewApplicationsValueNull() ApplicationsValue {
	return ApplicationsValue{
		state: attr.ValueStateNull,
	}
}

func NewApplicationsValueUnknown() ApplicationsValue {
	return ApplicationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApplicationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApplicationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApplicationsValue Attribute Value",
				"While creating a ApplicationsValue value, a missing attribute value was detected. "+
					"A ApplicationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApplicationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApplicationsValue Attribute Type",
				"While creating a ApplicationsValue value, an invalid attribute value was detected. "+
					"A ApplicationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApplicationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApplicationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApplicationsValue Attribute Value",
				"While creating a ApplicationsValue value, an extra attribute value was detected. "+
					"A ApplicationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApplicationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApplicationsValueUnknown(), diags
	}

	baseDirectoryAttribute, ok := attributes["base_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base_directory is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	baseDirectoryVal, ok := baseDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base_directory expected to be basetypes.StringValue, was: %T`, baseDirectoryAttribute))
	}

	buildCommandAttribute, ok := attributes["build_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`build_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	buildCommandVal, ok := buildCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`build_command expected to be basetypes.StringValue, was: %T`, buildCommandAttribute))
	}

	buildPackAttribute, ok := attributes["build_pack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`build_pack is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	buildPackVal, ok := buildPackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`build_pack expected to be basetypes.StringValue, was: %T`, buildPackAttribute))
	}

	composeParsingVersionAttribute, ok := attributes["compose_parsing_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`compose_parsing_version is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	composeParsingVersionVal, ok := composeParsingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`compose_parsing_version expected to be basetypes.StringValue, was: %T`, composeParsingVersionAttribute))
	}

	configHashAttribute, ok := attributes["config_hash"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_hash is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	configHashVal, ok := configHashAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_hash expected to be basetypes.StringValue, was: %T`, configHashAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	customDockerRunOptionsAttribute, ok := attributes["custom_docker_run_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_docker_run_options is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	customDockerRunOptionsVal, ok := customDockerRunOptionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_docker_run_options expected to be basetypes.StringValue, was: %T`, customDockerRunOptionsAttribute))
	}

	customHealthcheckFoundAttribute, ok := attributes["custom_healthcheck_found"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_healthcheck_found is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	customHealthcheckFoundVal, ok := customHealthcheckFoundAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_healthcheck_found expected to be basetypes.BoolValue, was: %T`, customHealthcheckFoundAttribute))
	}

	customLabelsAttribute, ok := attributes["custom_labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_labels is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	customLabelsVal, ok := customLabelsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_labels expected to be basetypes.StringValue, was: %T`, customLabelsAttribute))
	}

	customNginxConfigurationAttribute, ok := attributes["custom_nginx_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_nginx_configuration is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	customNginxConfigurationVal, ok := customNginxConfigurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_nginx_configuration expected to be basetypes.StringValue, was: %T`, customNginxConfigurationAttribute))
	}

	deletedAtAttribute, ok := attributes["deleted_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted_at is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	deletedAtVal, ok := deletedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted_at expected to be basetypes.StringValue, was: %T`, deletedAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	destinationIdAttribute, ok := attributes["destination_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_id is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	destinationIdVal, ok := destinationIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_id expected to be basetypes.Int64Value, was: %T`, destinationIdAttribute))
	}

	destinationTypeAttribute, ok := attributes["destination_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_type is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	destinationTypeVal, ok := destinationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_type expected to be basetypes.StringValue, was: %T`, destinationTypeAttribute))
	}

	dockerComposeAttribute, ok := attributes["docker_compose"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerComposeVal, ok := dockerComposeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose expected to be basetypes.StringValue, was: %T`, dockerComposeAttribute))
	}

	dockerComposeCustomBuildCommandAttribute, ok := attributes["docker_compose_custom_build_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_custom_build_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerComposeCustomBuildCommandVal, ok := dockerComposeCustomBuildCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_custom_build_command expected to be basetypes.StringValue, was: %T`, dockerComposeCustomBuildCommandAttribute))
	}

	dockerComposeCustomStartCommandAttribute, ok := attributes["docker_compose_custom_start_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_custom_start_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerComposeCustomStartCommandVal, ok := dockerComposeCustomStartCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_custom_start_command expected to be basetypes.StringValue, was: %T`, dockerComposeCustomStartCommandAttribute))
	}

	dockerComposeDomainsAttribute, ok := attributes["docker_compose_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_domains is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerComposeDomainsVal, ok := dockerComposeDomainsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_domains expected to be basetypes.StringValue, was: %T`, dockerComposeDomainsAttribute))
	}

	dockerComposeLocationAttribute, ok := attributes["docker_compose_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_location is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerComposeLocationVal, ok := dockerComposeLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_location expected to be basetypes.StringValue, was: %T`, dockerComposeLocationAttribute))
	}

	dockerComposeRawAttribute, ok := attributes["docker_compose_raw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_compose_raw is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerComposeRawVal, ok := dockerComposeRawAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_compose_raw expected to be basetypes.StringValue, was: %T`, dockerComposeRawAttribute))
	}

	dockerRegistryImageNameAttribute, ok := attributes["docker_registry_image_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_registry_image_name is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerRegistryImageNameVal, ok := dockerRegistryImageNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_registry_image_name expected to be basetypes.StringValue, was: %T`, dockerRegistryImageNameAttribute))
	}

	dockerRegistryImageTagAttribute, ok := attributes["docker_registry_image_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_registry_image_tag is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerRegistryImageTagVal, ok := dockerRegistryImageTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_registry_image_tag expected to be basetypes.StringValue, was: %T`, dockerRegistryImageTagAttribute))
	}

	dockerfileAttribute, ok := attributes["dockerfile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dockerfile is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerfileVal, ok := dockerfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dockerfile expected to be basetypes.StringValue, was: %T`, dockerfileAttribute))
	}

	dockerfileLocationAttribute, ok := attributes["dockerfile_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dockerfile_location is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerfileLocationVal, ok := dockerfileLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dockerfile_location expected to be basetypes.StringValue, was: %T`, dockerfileLocationAttribute))
	}

	dockerfileTargetBuildAttribute, ok := attributes["dockerfile_target_build"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dockerfile_target_build is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	dockerfileTargetBuildVal, ok := dockerfileTargetBuildAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dockerfile_target_build expected to be basetypes.StringValue, was: %T`, dockerfileTargetBuildAttribute))
	}

	environmentIdAttribute, ok := attributes["environment_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`environment_id is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	environmentIdVal, ok := environmentIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`environment_id expected to be basetypes.Int64Value, was: %T`, environmentIdAttribute))
	}

	fqdnAttribute, ok := attributes["fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fqdn is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	fqdnVal, ok := fqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fqdn expected to be basetypes.StringValue, was: %T`, fqdnAttribute))
	}

	gitBranchAttribute, ok := attributes["git_branch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_branch is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	gitBranchVal, ok := gitBranchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_branch expected to be basetypes.StringValue, was: %T`, gitBranchAttribute))
	}

	gitCommitShaAttribute, ok := attributes["git_commit_sha"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_commit_sha is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	gitCommitShaVal, ok := gitCommitShaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_commit_sha expected to be basetypes.StringValue, was: %T`, gitCommitShaAttribute))
	}

	gitFullUrlAttribute, ok := attributes["git_full_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_full_url is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	gitFullUrlVal, ok := gitFullUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_full_url expected to be basetypes.StringValue, was: %T`, gitFullUrlAttribute))
	}

	gitRepositoryAttribute, ok := attributes["git_repository"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`git_repository is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	gitRepositoryVal, ok := gitRepositoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`git_repository expected to be basetypes.StringValue, was: %T`, gitRepositoryAttribute))
	}

	healthCheckEnabledAttribute, ok := attributes["health_check_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_enabled is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckEnabledVal, ok := healthCheckEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_enabled expected to be basetypes.BoolValue, was: %T`, healthCheckEnabledAttribute))
	}

	healthCheckHostAttribute, ok := attributes["health_check_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_host is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckHostVal, ok := healthCheckHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_host expected to be basetypes.StringValue, was: %T`, healthCheckHostAttribute))
	}

	healthCheckIntervalAttribute, ok := attributes["health_check_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_interval is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckIntervalVal, ok := healthCheckIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_interval expected to be basetypes.Int64Value, was: %T`, healthCheckIntervalAttribute))
	}

	healthCheckMethodAttribute, ok := attributes["health_check_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_method is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckMethodVal, ok := healthCheckMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_method expected to be basetypes.StringValue, was: %T`, healthCheckMethodAttribute))
	}

	healthCheckPathAttribute, ok := attributes["health_check_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_path is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckPathVal, ok := healthCheckPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_path expected to be basetypes.StringValue, was: %T`, healthCheckPathAttribute))
	}

	healthCheckPortAttribute, ok := attributes["health_check_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_port is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckPortVal, ok := healthCheckPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_port expected to be basetypes.StringValue, was: %T`, healthCheckPortAttribute))
	}

	healthCheckResponseTextAttribute, ok := attributes["health_check_response_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_response_text is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckResponseTextVal, ok := healthCheckResponseTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_response_text expected to be basetypes.StringValue, was: %T`, healthCheckResponseTextAttribute))
	}

	healthCheckRetriesAttribute, ok := attributes["health_check_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_retries is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckRetriesVal, ok := healthCheckRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_retries expected to be basetypes.Int64Value, was: %T`, healthCheckRetriesAttribute))
	}

	healthCheckReturnCodeAttribute, ok := attributes["health_check_return_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_return_code is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckReturnCodeVal, ok := healthCheckReturnCodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_return_code expected to be basetypes.Int64Value, was: %T`, healthCheckReturnCodeAttribute))
	}

	healthCheckSchemeAttribute, ok := attributes["health_check_scheme"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_scheme is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckSchemeVal, ok := healthCheckSchemeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_scheme expected to be basetypes.StringValue, was: %T`, healthCheckSchemeAttribute))
	}

	healthCheckStartPeriodAttribute, ok := attributes["health_check_start_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_start_period is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckStartPeriodVal, ok := healthCheckStartPeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_start_period expected to be basetypes.Int64Value, was: %T`, healthCheckStartPeriodAttribute))
	}

	healthCheckTimeoutAttribute, ok := attributes["health_check_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_check_timeout is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	healthCheckTimeoutVal, ok := healthCheckTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_check_timeout expected to be basetypes.Int64Value, was: %T`, healthCheckTimeoutAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	installCommandAttribute, ok := attributes["install_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`install_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	installCommandVal, ok := installCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`install_command expected to be basetypes.StringValue, was: %T`, installCommandAttribute))
	}

	limitsCpuSharesAttribute, ok := attributes["limits_cpu_shares"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_cpu_shares is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsCpuSharesVal, ok := limitsCpuSharesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_cpu_shares expected to be basetypes.Int64Value, was: %T`, limitsCpuSharesAttribute))
	}

	limitsCpusAttribute, ok := attributes["limits_cpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_cpus is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsCpusVal, ok := limitsCpusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_cpus expected to be basetypes.StringValue, was: %T`, limitsCpusAttribute))
	}

	limitsCpusetAttribute, ok := attributes["limits_cpuset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_cpuset is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsCpusetVal, ok := limitsCpusetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_cpuset expected to be basetypes.StringValue, was: %T`, limitsCpusetAttribute))
	}

	limitsMemoryAttribute, ok := attributes["limits_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsMemoryVal, ok := limitsMemoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory expected to be basetypes.StringValue, was: %T`, limitsMemoryAttribute))
	}

	limitsMemoryReservationAttribute, ok := attributes["limits_memory_reservation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory_reservation is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsMemoryReservationVal, ok := limitsMemoryReservationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory_reservation expected to be basetypes.StringValue, was: %T`, limitsMemoryReservationAttribute))
	}

	limitsMemorySwapAttribute, ok := attributes["limits_memory_swap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory_swap is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsMemorySwapVal, ok := limitsMemorySwapAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory_swap expected to be basetypes.StringValue, was: %T`, limitsMemorySwapAttribute))
	}

	limitsMemorySwappinessAttribute, ok := attributes["limits_memory_swappiness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limits_memory_swappiness is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	limitsMemorySwappinessVal, ok := limitsMemorySwappinessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limits_memory_swappiness expected to be basetypes.Int64Value, was: %T`, limitsMemorySwappinessAttribute))
	}

	manualWebhookSecretBitbucketAttribute, ok := attributes["manual_webhook_secret_bitbucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_bitbucket is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	manualWebhookSecretBitbucketVal, ok := manualWebhookSecretBitbucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_bitbucket expected to be basetypes.StringValue, was: %T`, manualWebhookSecretBitbucketAttribute))
	}

	manualWebhookSecretGiteaAttribute, ok := attributes["manual_webhook_secret_gitea"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_gitea is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	manualWebhookSecretGiteaVal, ok := manualWebhookSecretGiteaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_gitea expected to be basetypes.StringValue, was: %T`, manualWebhookSecretGiteaAttribute))
	}

	manualWebhookSecretGithubAttribute, ok := attributes["manual_webhook_secret_github"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_github is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	manualWebhookSecretGithubVal, ok := manualWebhookSecretGithubAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_github expected to be basetypes.StringValue, was: %T`, manualWebhookSecretGithubAttribute))
	}

	manualWebhookSecretGitlabAttribute, ok := attributes["manual_webhook_secret_gitlab"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual_webhook_secret_gitlab is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	manualWebhookSecretGitlabVal, ok := manualWebhookSecretGitlabAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual_webhook_secret_gitlab expected to be basetypes.StringValue, was: %T`, manualWebhookSecretGitlabAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portsExposesAttribute, ok := attributes["ports_exposes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports_exposes is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	portsExposesVal, ok := portsExposesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports_exposes expected to be basetypes.StringValue, was: %T`, portsExposesAttribute))
	}

	portsMappingsAttribute, ok := attributes["ports_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports_mappings is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	portsMappingsVal, ok := portsMappingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports_mappings expected to be basetypes.StringValue, was: %T`, portsMappingsAttribute))
	}

	postDeploymentCommandAttribute, ok := attributes["post_deployment_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`post_deployment_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	postDeploymentCommandVal, ok := postDeploymentCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`post_deployment_command expected to be basetypes.StringValue, was: %T`, postDeploymentCommandAttribute))
	}

	postDeploymentCommandContainerAttribute, ok := attributes["post_deployment_command_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`post_deployment_command_container is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	postDeploymentCommandContainerVal, ok := postDeploymentCommandContainerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`post_deployment_command_container expected to be basetypes.StringValue, was: %T`, postDeploymentCommandContainerAttribute))
	}

	preDeploymentCommandAttribute, ok := attributes["pre_deployment_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_deployment_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	preDeploymentCommandVal, ok := preDeploymentCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_deployment_command expected to be basetypes.StringValue, was: %T`, preDeploymentCommandAttribute))
	}

	preDeploymentCommandContainerAttribute, ok := attributes["pre_deployment_command_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_deployment_command_container is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	preDeploymentCommandContainerVal, ok := preDeploymentCommandContainerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_deployment_command_container expected to be basetypes.StringValue, was: %T`, preDeploymentCommandContainerAttribute))
	}

	previewUrlTemplateAttribute, ok := attributes["preview_url_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preview_url_template is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	previewUrlTemplateVal, ok := previewUrlTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preview_url_template expected to be basetypes.StringValue, was: %T`, previewUrlTemplateAttribute))
	}

	privateKeyIdAttribute, ok := attributes["private_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key_id is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	privateKeyIdVal, ok := privateKeyIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key_id expected to be basetypes.Int64Value, was: %T`, privateKeyIdAttribute))
	}

	publishDirectoryAttribute, ok := attributes["publish_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`publish_directory is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	publishDirectoryVal, ok := publishDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`publish_directory expected to be basetypes.StringValue, was: %T`, publishDirectoryAttribute))
	}

	redirectAttribute, ok := attributes["redirect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redirect is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	redirectVal, ok := redirectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redirect expected to be basetypes.StringValue, was: %T`, redirectAttribute))
	}

	repositoryProjectIdAttribute, ok := attributes["repository_project_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repository_project_id is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	repositoryProjectIdVal, ok := repositoryProjectIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repository_project_id expected to be basetypes.Int64Value, was: %T`, repositoryProjectIdAttribute))
	}

	sourceIdAttribute, ok := attributes["source_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_id is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	sourceIdVal, ok := sourceIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_id expected to be basetypes.Int64Value, was: %T`, sourceIdAttribute))
	}

	startCommandAttribute, ok := attributes["start_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_command is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	startCommandVal, ok := startCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_command expected to be basetypes.StringValue, was: %T`, startCommandAttribute))
	}

	staticImageAttribute, ok := attributes["static_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_image is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	staticImageVal, ok := staticImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_image expected to be basetypes.StringValue, was: %T`, staticImageAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	swarmPlacementConstraintsAttribute, ok := attributes["swarm_placement_constraints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`swarm_placement_constraints is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	swarmPlacementConstraintsVal, ok := swarmPlacementConstraintsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`swarm_placement_constraints expected to be basetypes.StringValue, was: %T`, swarmPlacementConstraintsAttribute))
	}

	swarmReplicasAttribute, ok := attributes["swarm_replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`swarm_replicas is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	swarmReplicasVal, ok := swarmReplicasAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`swarm_replicas expected to be basetypes.Int64Value, was: %T`, swarmReplicasAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	watchPathsAttribute, ok := attributes["watch_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`watch_paths is missing from object`)

		return NewApplicationsValueUnknown(), diags
	}

	watchPathsVal, ok := watchPathsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`watch_paths expected to be basetypes.StringValue, was: %T`, watchPathsAttribute))
	}

	if diags.HasError() {
		return NewApplicationsValueUnknown(), diags
	}

	return ApplicationsValue{
		BaseDirectory:                   baseDirectoryVal,
		BuildCommand:                    buildCommandVal,
		BuildPack:                       buildPackVal,
		ComposeParsingVersion:           composeParsingVersionVal,
		ConfigHash:                      configHashVal,
		CreatedAt:                       createdAtVal,
		CustomDockerRunOptions:          customDockerRunOptionsVal,
		CustomHealthcheckFound:          customHealthcheckFoundVal,
		CustomLabels:                    customLabelsVal,
		CustomNginxConfiguration:        customNginxConfigurationVal,
		DeletedAt:                       deletedAtVal,
		Description:                     descriptionVal,
		DestinationId:                   destinationIdVal,
		DestinationType:                 destinationTypeVal,
		DockerCompose:                   dockerComposeVal,
		DockerComposeCustomBuildCommand: dockerComposeCustomBuildCommandVal,
		DockerComposeCustomStartCommand: dockerComposeCustomStartCommandVal,
		DockerComposeDomains:            dockerComposeDomainsVal,
		DockerComposeLocation:           dockerComposeLocationVal,
		DockerComposeRaw:                dockerComposeRawVal,
		DockerRegistryImageName:         dockerRegistryImageNameVal,
		DockerRegistryImageTag:          dockerRegistryImageTagVal,
		Dockerfile:                      dockerfileVal,
		DockerfileLocation:              dockerfileLocationVal,
		DockerfileTargetBuild:           dockerfileTargetBuildVal,
		EnvironmentId:                   environmentIdVal,
		Fqdn:                            fqdnVal,
		GitBranch:                       gitBranchVal,
		GitCommitSha:                    gitCommitShaVal,
		GitFullUrl:                      gitFullUrlVal,
		GitRepository:                   gitRepositoryVal,
		HealthCheckEnabled:              healthCheckEnabledVal,
		HealthCheckHost:                 healthCheckHostVal,
		HealthCheckInterval:             healthCheckIntervalVal,
		HealthCheckMethod:               healthCheckMethodVal,
		HealthCheckPath:                 healthCheckPathVal,
		HealthCheckPort:                 healthCheckPortVal,
		HealthCheckResponseText:         healthCheckResponseTextVal,
		HealthCheckRetries:              healthCheckRetriesVal,
		HealthCheckReturnCode:           healthCheckReturnCodeVal,
		HealthCheckScheme:               healthCheckSchemeVal,
		HealthCheckStartPeriod:          healthCheckStartPeriodVal,
		HealthCheckTimeout:              healthCheckTimeoutVal,
		Id:                              idVal,
		InstallCommand:                  installCommandVal,
		LimitsCpuShares:                 limitsCpuSharesVal,
		LimitsCpus:                      limitsCpusVal,
		LimitsCpuset:                    limitsCpusetVal,
		LimitsMemory:                    limitsMemoryVal,
		LimitsMemoryReservation:         limitsMemoryReservationVal,
		LimitsMemorySwap:                limitsMemorySwapVal,
		LimitsMemorySwappiness:          limitsMemorySwappinessVal,
		ManualWebhookSecretBitbucket:    manualWebhookSecretBitbucketVal,
		ManualWebhookSecretGitea:        manualWebhookSecretGiteaVal,
		ManualWebhookSecretGithub:       manualWebhookSecretGithubVal,
		ManualWebhookSecretGitlab:       manualWebhookSecretGitlabVal,
		Name:                            nameVal,
		PortsExposes:                    portsExposesVal,
		PortsMappings:                   portsMappingsVal,
		PostDeploymentCommand:           postDeploymentCommandVal,
		PostDeploymentCommandContainer:  postDeploymentCommandContainerVal,
		PreDeploymentCommand:            preDeploymentCommandVal,
		PreDeploymentCommandContainer:   preDeploymentCommandContainerVal,
		PreviewUrlTemplate:              previewUrlTemplateVal,
		PrivateKeyId:                    privateKeyIdVal,
		PublishDirectory:                publishDirectoryVal,
		Redirect:                        redirectVal,
		RepositoryProjectId:             repositoryProjectIdVal,
		SourceId:                        sourceIdVal,
		StartCommand:                    startCommandVal,
		StaticImage:                     staticImageVal,
		Status:                          statusVal,
		SwarmPlacementConstraints:       swarmPlacementConstraintsVal,
		SwarmReplicas:                   swarmReplicasVal,
		UpdatedAt:                       updatedAtVal,
		Uuid:                            uuidVal,
		WatchPaths:                      watchPathsVal,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewApplicationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApplicationsValue {
	object, diags := NewApplicationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApplicationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApplicationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApplicationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApplicationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApplicationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApplicationsValueMust(ApplicationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApplicationsType) ValueType(ctx context.Context) attr.Value {
	return ApplicationsValue{}
}

var _ basetypes.ObjectValuable = ApplicationsValue{}

type ApplicationsValue struct {
	BaseDirectory                   basetypes.StringValue `tfsdk:"base_directory"`
	BuildCommand                    basetypes.StringValue `tfsdk:"build_command"`
	BuildPack                       basetypes.StringValue `tfsdk:"build_pack"`
	ComposeParsingVersion           basetypes.StringValue `tfsdk:"compose_parsing_version"`
	ConfigHash                      basetypes.StringValue `tfsdk:"config_hash"`
	CreatedAt                       basetypes.StringValue `tfsdk:"created_at"`
	CustomDockerRunOptions          basetypes.StringValue `tfsdk:"custom_docker_run_options"`
	CustomHealthcheckFound          basetypes.BoolValue   `tfsdk:"custom_healthcheck_found"`
	CustomLabels                    basetypes.StringValue `tfsdk:"custom_labels"`
	CustomNginxConfiguration        basetypes.StringValue `tfsdk:"custom_nginx_configuration"`
	DeletedAt                       basetypes.StringValue `tfsdk:"deleted_at"`
	Description                     basetypes.StringValue `tfsdk:"description"`
	DestinationId                   basetypes.Int64Value  `tfsdk:"destination_id"`
	DestinationType                 basetypes.StringValue `tfsdk:"destination_type"`
	DockerCompose                   basetypes.StringValue `tfsdk:"docker_compose"`
	DockerComposeCustomBuildCommand basetypes.StringValue `tfsdk:"docker_compose_custom_build_command"`
	DockerComposeCustomStartCommand basetypes.StringValue `tfsdk:"docker_compose_custom_start_command"`
	DockerComposeDomains            basetypes.StringValue `tfsdk:"docker_compose_domains"`
	DockerComposeLocation           basetypes.StringValue `tfsdk:"docker_compose_location"`
	DockerComposeRaw                basetypes.StringValue `tfsdk:"docker_compose_raw"`
	DockerRegistryImageName         basetypes.StringValue `tfsdk:"docker_registry_image_name"`
	DockerRegistryImageTag          basetypes.StringValue `tfsdk:"docker_registry_image_tag"`
	Dockerfile                      basetypes.StringValue `tfsdk:"dockerfile"`
	DockerfileLocation              basetypes.StringValue `tfsdk:"dockerfile_location"`
	DockerfileTargetBuild           basetypes.StringValue `tfsdk:"dockerfile_target_build"`
	EnvironmentId                   basetypes.Int64Value  `tfsdk:"environment_id"`
	Fqdn                            basetypes.StringValue `tfsdk:"fqdn"`
	GitBranch                       basetypes.StringValue `tfsdk:"git_branch"`
	GitCommitSha                    basetypes.StringValue `tfsdk:"git_commit_sha"`
	GitFullUrl                      basetypes.StringValue `tfsdk:"git_full_url"`
	GitRepository                   basetypes.StringValue `tfsdk:"git_repository"`
	HealthCheckEnabled              basetypes.BoolValue   `tfsdk:"health_check_enabled"`
	HealthCheckHost                 basetypes.StringValue `tfsdk:"health_check_host"`
	HealthCheckInterval             basetypes.Int64Value  `tfsdk:"health_check_interval"`
	HealthCheckMethod               basetypes.StringValue `tfsdk:"health_check_method"`
	HealthCheckPath                 basetypes.StringValue `tfsdk:"health_check_path"`
	HealthCheckPort                 basetypes.StringValue `tfsdk:"health_check_port"`
	HealthCheckResponseText         basetypes.StringValue `tfsdk:"health_check_response_text"`
	HealthCheckRetries              basetypes.Int64Value  `tfsdk:"health_check_retries"`
	HealthCheckReturnCode           basetypes.Int64Value  `tfsdk:"health_check_return_code"`
	HealthCheckScheme               basetypes.StringValue `tfsdk:"health_check_scheme"`
	HealthCheckStartPeriod          basetypes.Int64Value  `tfsdk:"health_check_start_period"`
	HealthCheckTimeout              basetypes.Int64Value  `tfsdk:"health_check_timeout"`
	Id                              basetypes.Int64Value  `tfsdk:"id"`
	InstallCommand                  basetypes.StringValue `tfsdk:"install_command"`
	LimitsCpuShares                 basetypes.Int64Value  `tfsdk:"limits_cpu_shares"`
	LimitsCpus                      basetypes.StringValue `tfsdk:"limits_cpus"`
	LimitsCpuset                    basetypes.StringValue `tfsdk:"limits_cpuset"`
	LimitsMemory                    basetypes.StringValue `tfsdk:"limits_memory"`
	LimitsMemoryReservation         basetypes.StringValue `tfsdk:"limits_memory_reservation"`
	LimitsMemorySwap                basetypes.StringValue `tfsdk:"limits_memory_swap"`
	LimitsMemorySwappiness          basetypes.Int64Value  `tfsdk:"limits_memory_swappiness"`
	ManualWebhookSecretBitbucket    basetypes.StringValue `tfsdk:"manual_webhook_secret_bitbucket"`
	ManualWebhookSecretGitea        basetypes.StringValue `tfsdk:"manual_webhook_secret_gitea"`
	ManualWebhookSecretGithub       basetypes.StringValue `tfsdk:"manual_webhook_secret_github"`
	ManualWebhookSecretGitlab       basetypes.StringValue `tfsdk:"manual_webhook_secret_gitlab"`
	Name                            basetypes.StringValue `tfsdk:"name"`
	PortsExposes                    basetypes.StringValue `tfsdk:"ports_exposes"`
	PortsMappings                   basetypes.StringValue `tfsdk:"ports_mappings"`
	PostDeploymentCommand           basetypes.StringValue `tfsdk:"post_deployment_command"`
	PostDeploymentCommandContainer  basetypes.StringValue `tfsdk:"post_deployment_command_container"`
	PreDeploymentCommand            basetypes.StringValue `tfsdk:"pre_deployment_command"`
	PreDeploymentCommandContainer   basetypes.StringValue `tfsdk:"pre_deployment_command_container"`
	PreviewUrlTemplate              basetypes.StringValue `tfsdk:"preview_url_template"`
	PrivateKeyId                    basetypes.Int64Value  `tfsdk:"private_key_id"`
	PublishDirectory                basetypes.StringValue `tfsdk:"publish_directory"`
	Redirect                        basetypes.StringValue `tfsdk:"redirect"`
	RepositoryProjectId             basetypes.Int64Value  `tfsdk:"repository_project_id"`
	SourceId                        basetypes.Int64Value  `tfsdk:"source_id"`
	StartCommand                    basetypes.StringValue `tfsdk:"start_command"`
	StaticImage                     basetypes.StringValue `tfsdk:"static_image"`
	Status                          basetypes.StringValue `tfsdk:"status"`
	SwarmPlacementConstraints       basetypes.StringValue `tfsdk:"swarm_placement_constraints"`
	SwarmReplicas                   basetypes.Int64Value  `tfsdk:"swarm_replicas"`
	UpdatedAt                       basetypes.StringValue `tfsdk:"updated_at"`
	Uuid                            basetypes.StringValue `tfsdk:"uuid"`
	WatchPaths                      basetypes.StringValue `tfsdk:"watch_paths"`
	state                           attr.ValueState
}

func (v ApplicationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 77)

	var val tftypes.Value
	var err error

	attrTypes["base_directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["build_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["build_pack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["compose_parsing_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["config_hash"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_docker_run_options"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_healthcheck_found"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["custom_labels"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_nginx_configuration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deleted_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["destination_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_compose"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_compose_custom_build_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_compose_custom_start_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_compose_domains"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_compose_location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_compose_raw"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_registry_image_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_registry_image_tag"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dockerfile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dockerfile_location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dockerfile_target_build"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["environment_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["fqdn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["git_branch"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["git_commit_sha"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["git_full_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["git_repository"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["health_check_host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_check_method"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_response_text"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_check_return_code"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_check_scheme"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health_check_start_period"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_check_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["install_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limits_cpu_shares"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["limits_cpus"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limits_cpuset"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limits_memory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limits_memory_reservation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limits_memory_swap"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limits_memory_swappiness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["manual_webhook_secret_bitbucket"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["manual_webhook_secret_gitea"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["manual_webhook_secret_github"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["manual_webhook_secret_gitlab"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ports_exposes"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ports_mappings"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["post_deployment_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["post_deployment_command_container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pre_deployment_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pre_deployment_command_container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preview_url_template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_key_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["publish_directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redirect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["repository_project_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["source_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["static_image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["swarm_placement_constraints"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["swarm_replicas"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["watch_paths"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 77)

		val, err = v.BaseDirectory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["base_directory"] = val

		val, err = v.BuildCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["build_command"] = val

		val, err = v.BuildPack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["build_pack"] = val

		val, err = v.ComposeParsingVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["compose_parsing_version"] = val

		val, err = v.ConfigHash.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_hash"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CustomDockerRunOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_docker_run_options"] = val

		val, err = v.CustomHealthcheckFound.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_healthcheck_found"] = val

		val, err = v.CustomLabels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_labels"] = val

		val, err = v.CustomNginxConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_nginx_configuration"] = val

		val, err = v.DeletedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DestinationId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_id"] = val

		val, err = v.DestinationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_type"] = val

		val, err = v.DockerCompose.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_compose"] = val

		val, err = v.DockerComposeCustomBuildCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_compose_custom_build_command"] = val

		val, err = v.DockerComposeCustomStartCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_compose_custom_start_command"] = val

		val, err = v.DockerComposeDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_compose_domains"] = val

		val, err = v.DockerComposeLocation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_compose_location"] = val

		val, err = v.DockerComposeRaw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_compose_raw"] = val

		val, err = v.DockerRegistryImageName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_registry_image_name"] = val

		val, err = v.DockerRegistryImageTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_registry_image_tag"] = val

		val, err = v.Dockerfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dockerfile"] = val

		val, err = v.DockerfileLocation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dockerfile_location"] = val

		val, err = v.DockerfileTargetBuild.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dockerfile_target_build"] = val

		val, err = v.EnvironmentId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["environment_id"] = val

		val, err = v.Fqdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fqdn"] = val

		val, err = v.GitBranch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["git_branch"] = val

		val, err = v.GitCommitSha.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["git_commit_sha"] = val

		val, err = v.GitFullUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["git_full_url"] = val

		val, err = v.GitRepository.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["git_repository"] = val

		val, err = v.HealthCheckEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_enabled"] = val

		val, err = v.HealthCheckHost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_host"] = val

		val, err = v.HealthCheckInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_interval"] = val

		val, err = v.HealthCheckMethod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_method"] = val

		val, err = v.HealthCheckPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_path"] = val

		val, err = v.HealthCheckPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_port"] = val

		val, err = v.HealthCheckResponseText.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_response_text"] = val

		val, err = v.HealthCheckRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_retries"] = val

		val, err = v.HealthCheckReturnCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_return_code"] = val

		val, err = v.HealthCheckScheme.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_scheme"] = val

		val, err = v.HealthCheckStartPeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_start_period"] = val

		val, err = v.HealthCheckTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_check_timeout"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.InstallCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["install_command"] = val

		val, err = v.LimitsCpuShares.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_cpu_shares"] = val

		val, err = v.LimitsCpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_cpus"] = val

		val, err = v.LimitsCpuset.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_cpuset"] = val

		val, err = v.LimitsMemory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_memory"] = val

		val, err = v.LimitsMemoryReservation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_memory_reservation"] = val

		val, err = v.LimitsMemorySwap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_memory_swap"] = val

		val, err = v.LimitsMemorySwappiness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limits_memory_swappiness"] = val

		val, err = v.ManualWebhookSecretBitbucket.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manual_webhook_secret_bitbucket"] = val

		val, err = v.ManualWebhookSecretGitea.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manual_webhook_secret_gitea"] = val

		val, err = v.ManualWebhookSecretGithub.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manual_webhook_secret_github"] = val

		val, err = v.ManualWebhookSecretGitlab.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manual_webhook_secret_gitlab"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PortsExposes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports_exposes"] = val

		val, err = v.PortsMappings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports_mappings"] = val

		val, err = v.PostDeploymentCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["post_deployment_command"] = val

		val, err = v.PostDeploymentCommandContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["post_deployment_command_container"] = val

		val, err = v.PreDeploymentCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_deployment_command"] = val

		val, err = v.PreDeploymentCommandContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_deployment_command_container"] = val

		val, err = v.PreviewUrlTemplate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preview_url_template"] = val

		val, err = v.PrivateKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_key_id"] = val

		val, err = v.PublishDirectory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["publish_directory"] = val

		val, err = v.Redirect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redirect"] = val

		val, err = v.RepositoryProjectId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["repository_project_id"] = val

		val, err = v.SourceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_id"] = val

		val, err = v.StartCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_command"] = val

		val, err = v.StaticImage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_image"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.SwarmPlacementConstraints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["swarm_placement_constraints"] = val

		val, err = v.SwarmReplicas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["swarm_replicas"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		val, err = v.WatchPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["watch_paths"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApplicationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApplicationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApplicationsValue) String() string {
	return "ApplicationsValue"
}

func (v ApplicationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"base_directory":                      basetypes.StringType{},
		"build_command":                       basetypes.StringType{},
		"build_pack":                          basetypes.StringType{},
		"compose_parsing_version":             basetypes.StringType{},
		"config_hash":                         basetypes.StringType{},
		"created_at":                          basetypes.StringType{},
		"custom_docker_run_options":           basetypes.StringType{},
		"custom_healthcheck_found":            basetypes.BoolType{},
		"custom_labels":                       basetypes.StringType{},
		"custom_nginx_configuration":          basetypes.StringType{},
		"deleted_at":                          basetypes.StringType{},
		"description":                         basetypes.StringType{},
		"destination_id":                      basetypes.Int64Type{},
		"destination_type":                    basetypes.StringType{},
		"docker_compose":                      basetypes.StringType{},
		"docker_compose_custom_build_command": basetypes.StringType{},
		"docker_compose_custom_start_command": basetypes.StringType{},
		"docker_compose_domains":              basetypes.StringType{},
		"docker_compose_location":             basetypes.StringType{},
		"docker_compose_raw":                  basetypes.StringType{},
		"docker_registry_image_name":          basetypes.StringType{},
		"docker_registry_image_tag":           basetypes.StringType{},
		"dockerfile":                          basetypes.StringType{},
		"dockerfile_location":                 basetypes.StringType{},
		"dockerfile_target_build":             basetypes.StringType{},
		"environment_id":                      basetypes.Int64Type{},
		"fqdn":                                basetypes.StringType{},
		"git_branch":                          basetypes.StringType{},
		"git_commit_sha":                      basetypes.StringType{},
		"git_full_url":                        basetypes.StringType{},
		"git_repository":                      basetypes.StringType{},
		"health_check_enabled":                basetypes.BoolType{},
		"health_check_host":                   basetypes.StringType{},
		"health_check_interval":               basetypes.Int64Type{},
		"health_check_method":                 basetypes.StringType{},
		"health_check_path":                   basetypes.StringType{},
		"health_check_port":                   basetypes.StringType{},
		"health_check_response_text":          basetypes.StringType{},
		"health_check_retries":                basetypes.Int64Type{},
		"health_check_return_code":            basetypes.Int64Type{},
		"health_check_scheme":                 basetypes.StringType{},
		"health_check_start_period":           basetypes.Int64Type{},
		"health_check_timeout":                basetypes.Int64Type{},
		"id":                                  basetypes.Int64Type{},
		"install_command":                     basetypes.StringType{},
		"limits_cpu_shares":                   basetypes.Int64Type{},
		"limits_cpus":                         basetypes.StringType{},
		"limits_cpuset":                       basetypes.StringType{},
		"limits_memory":                       basetypes.StringType{},
		"limits_memory_reservation":           basetypes.StringType{},
		"limits_memory_swap":                  basetypes.StringType{},
		"limits_memory_swappiness":            basetypes.Int64Type{},
		"manual_webhook_secret_bitbucket":     basetypes.StringType{},
		"manual_webhook_secret_gitea":         basetypes.StringType{},
		"manual_webhook_secret_github":        basetypes.StringType{},
		"manual_webhook_secret_gitlab":        basetypes.StringType{},
		"name":                                basetypes.StringType{},
		"ports_exposes":                       basetypes.StringType{},
		"ports_mappings":                      basetypes.StringType{},
		"post_deployment_command":             basetypes.StringType{},
		"post_deployment_command_container":   basetypes.StringType{},
		"pre_deployment_command":              basetypes.StringType{},
		"pre_deployment_command_container":    basetypes.StringType{},
		"preview_url_template":                basetypes.StringType{},
		"private_key_id":                      basetypes.Int64Type{},
		"publish_directory":                   basetypes.StringType{},
		"redirect":                            basetypes.StringType{},
		"repository_project_id":               basetypes.Int64Type{},
		"source_id":                           basetypes.Int64Type{},
		"start_command":                       basetypes.StringType{},
		"static_image":                        basetypes.StringType{},
		"status":                              basetypes.StringType{},
		"swarm_placement_constraints":         basetypes.StringType{},
		"swarm_replicas":                      basetypes.Int64Type{},
		"updated_at":                          basetypes.StringType{},
		"uuid":                                basetypes.StringType{},
		"watch_paths":                         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"base_directory":                      v.BaseDirectory,
			"build_command":                       v.BuildCommand,
			"build_pack":                          v.BuildPack,
			"compose_parsing_version":             v.ComposeParsingVersion,
			"config_hash":                         v.ConfigHash,
			"created_at":                          v.CreatedAt,
			"custom_docker_run_options":           v.CustomDockerRunOptions,
			"custom_healthcheck_found":            v.CustomHealthcheckFound,
			"custom_labels":                       v.CustomLabels,
			"custom_nginx_configuration":          v.CustomNginxConfiguration,
			"deleted_at":                          v.DeletedAt,
			"description":                         v.Description,
			"destination_id":                      v.DestinationId,
			"destination_type":                    v.DestinationType,
			"docker_compose":                      v.DockerCompose,
			"docker_compose_custom_build_command": v.DockerComposeCustomBuildCommand,
			"docker_compose_custom_start_command": v.DockerComposeCustomStartCommand,
			"docker_compose_domains":              v.DockerComposeDomains,
			"docker_compose_location":             v.DockerComposeLocation,
			"docker_compose_raw":                  v.DockerComposeRaw,
			"docker_registry_image_name":          v.DockerRegistryImageName,
			"docker_registry_image_tag":           v.DockerRegistryImageTag,
			"dockerfile":                          v.Dockerfile,
			"dockerfile_location":                 v.DockerfileLocation,
			"dockerfile_target_build":             v.DockerfileTargetBuild,
			"environment_id":                      v.EnvironmentId,
			"fqdn":                                v.Fqdn,
			"git_branch":                          v.GitBranch,
			"git_commit_sha":                      v.GitCommitSha,
			"git_full_url":                        v.GitFullUrl,
			"git_repository":                      v.GitRepository,
			"health_check_enabled":                v.HealthCheckEnabled,
			"health_check_host":                   v.HealthCheckHost,
			"health_check_interval":               v.HealthCheckInterval,
			"health_check_method":                 v.HealthCheckMethod,
			"health_check_path":                   v.HealthCheckPath,
			"health_check_port":                   v.HealthCheckPort,
			"health_check_response_text":          v.HealthCheckResponseText,
			"health_check_retries":                v.HealthCheckRetries,
			"health_check_return_code":            v.HealthCheckReturnCode,
			"health_check_scheme":                 v.HealthCheckScheme,
			"health_check_start_period":           v.HealthCheckStartPeriod,
			"health_check_timeout":                v.HealthCheckTimeout,
			"id":                                  v.Id,
			"install_command":                     v.InstallCommand,
			"limits_cpu_shares":                   v.LimitsCpuShares,
			"limits_cpus":                         v.LimitsCpus,
			"limits_cpuset":                       v.LimitsCpuset,
			"limits_memory":                       v.LimitsMemory,
			"limits_memory_reservation":           v.LimitsMemoryReservation,
			"limits_memory_swap":                  v.LimitsMemorySwap,
			"limits_memory_swappiness":            v.LimitsMemorySwappiness,
			"manual_webhook_secret_bitbucket":     v.ManualWebhookSecretBitbucket,
			"manual_webhook_secret_gitea":         v.ManualWebhookSecretGitea,
			"manual_webhook_secret_github":        v.ManualWebhookSecretGithub,
			"manual_webhook_secret_gitlab":        v.ManualWebhookSecretGitlab,
			"name":                                v.Name,
			"ports_exposes":                       v.PortsExposes,
			"ports_mappings":                      v.PortsMappings,
			"post_deployment_command":             v.PostDeploymentCommand,
			"post_deployment_command_container":   v.PostDeploymentCommandContainer,
			"pre_deployment_command":              v.PreDeploymentCommand,
			"pre_deployment_command_container":    v.PreDeploymentCommandContainer,
			"preview_url_template":                v.PreviewUrlTemplate,
			"private_key_id":                      v.PrivateKeyId,
			"publish_directory":                   v.PublishDirectory,
			"redirect":                            v.Redirect,
			"repository_project_id":               v.RepositoryProjectId,
			"source_id":                           v.SourceId,
			"start_command":                       v.StartCommand,
			"static_image":                        v.StaticImage,
			"status":                              v.Status,
			"swarm_placement_constraints":         v.SwarmPlacementConstraints,
			"swarm_replicas":                      v.SwarmReplicas,
			"updated_at":                          v.UpdatedAt,
			"uuid":                                v.Uuid,
			"watch_paths":                         v.WatchPaths,
		})

	return objVal, diags
}

func (v ApplicationsValue) Equal(o attr.Value) bool {
	other, ok := o.(ApplicationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BaseDirectory.Equal(other.BaseDirectory) {
		return false
	}

	if !v.BuildCommand.Equal(other.BuildCommand) {
		return false
	}

	if !v.BuildPack.Equal(other.BuildPack) {
		return false
	}

	if !v.ComposeParsingVersion.Equal(other.ComposeParsingVersion) {
		return false
	}

	if !v.ConfigHash.Equal(other.ConfigHash) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CustomDockerRunOptions.Equal(other.CustomDockerRunOptions) {
		return false
	}

	if !v.CustomHealthcheckFound.Equal(other.CustomHealthcheckFound) {
		return false
	}

	if !v.CustomLabels.Equal(other.CustomLabels) {
		return false
	}

	if !v.CustomNginxConfiguration.Equal(other.CustomNginxConfiguration) {
		return false
	}

	if !v.DeletedAt.Equal(other.DeletedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DestinationId.Equal(other.DestinationId) {
		return false
	}

	if !v.DestinationType.Equal(other.DestinationType) {
		return false
	}

	if !v.DockerCompose.Equal(other.DockerCompose) {
		return false
	}

	if !v.DockerComposeCustomBuildCommand.Equal(other.DockerComposeCustomBuildCommand) {
		return false
	}

	if !v.DockerComposeCustomStartCommand.Equal(other.DockerComposeCustomStartCommand) {
		return false
	}

	if !v.DockerComposeDomains.Equal(other.DockerComposeDomains) {
		return false
	}

	if !v.DockerComposeLocation.Equal(other.DockerComposeLocation) {
		return false
	}

	if !v.DockerComposeRaw.Equal(other.DockerComposeRaw) {
		return false
	}

	if !v.DockerRegistryImageName.Equal(other.DockerRegistryImageName) {
		return false
	}

	if !v.DockerRegistryImageTag.Equal(other.DockerRegistryImageTag) {
		return false
	}

	if !v.Dockerfile.Equal(other.Dockerfile) {
		return false
	}

	if !v.DockerfileLocation.Equal(other.DockerfileLocation) {
		return false
	}

	if !v.DockerfileTargetBuild.Equal(other.DockerfileTargetBuild) {
		return false
	}

	if !v.EnvironmentId.Equal(other.EnvironmentId) {
		return false
	}

	if !v.Fqdn.Equal(other.Fqdn) {
		return false
	}

	if !v.GitBranch.Equal(other.GitBranch) {
		return false
	}

	if !v.GitCommitSha.Equal(other.GitCommitSha) {
		return false
	}

	if !v.GitFullUrl.Equal(other.GitFullUrl) {
		return false
	}

	if !v.GitRepository.Equal(other.GitRepository) {
		return false
	}

	if !v.HealthCheckEnabled.Equal(other.HealthCheckEnabled) {
		return false
	}

	if !v.HealthCheckHost.Equal(other.HealthCheckHost) {
		return false
	}

	if !v.HealthCheckInterval.Equal(other.HealthCheckInterval) {
		return false
	}

	if !v.HealthCheckMethod.Equal(other.HealthCheckMethod) {
		return false
	}

	if !v.HealthCheckPath.Equal(other.HealthCheckPath) {
		return false
	}

	if !v.HealthCheckPort.Equal(other.HealthCheckPort) {
		return false
	}

	if !v.HealthCheckResponseText.Equal(other.HealthCheckResponseText) {
		return false
	}

	if !v.HealthCheckRetries.Equal(other.HealthCheckRetries) {
		return false
	}

	if !v.HealthCheckReturnCode.Equal(other.HealthCheckReturnCode) {
		return false
	}

	if !v.HealthCheckScheme.Equal(other.HealthCheckScheme) {
		return false
	}

	if !v.HealthCheckStartPeriod.Equal(other.HealthCheckStartPeriod) {
		return false
	}

	if !v.HealthCheckTimeout.Equal(other.HealthCheckTimeout) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.InstallCommand.Equal(other.InstallCommand) {
		return false
	}

	if !v.LimitsCpuShares.Equal(other.LimitsCpuShares) {
		return false
	}

	if !v.LimitsCpus.Equal(other.LimitsCpus) {
		return false
	}

	if !v.LimitsCpuset.Equal(other.LimitsCpuset) {
		return false
	}

	if !v.LimitsMemory.Equal(other.LimitsMemory) {
		return false
	}

	if !v.LimitsMemoryReservation.Equal(other.LimitsMemoryReservation) {
		return false
	}

	if !v.LimitsMemorySwap.Equal(other.LimitsMemorySwap) {
		return false
	}

	if !v.LimitsMemorySwappiness.Equal(other.LimitsMemorySwappiness) {
		return false
	}

	if !v.ManualWebhookSecretBitbucket.Equal(other.ManualWebhookSecretBitbucket) {
		return false
	}

	if !v.ManualWebhookSecretGitea.Equal(other.ManualWebhookSecretGitea) {
		return false
	}

	if !v.ManualWebhookSecretGithub.Equal(other.ManualWebhookSecretGithub) {
		return false
	}

	if !v.ManualWebhookSecretGitlab.Equal(other.ManualWebhookSecretGitlab) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PortsExposes.Equal(other.PortsExposes) {
		return false
	}

	if !v.PortsMappings.Equal(other.PortsMappings) {
		return false
	}

	if !v.PostDeploymentCommand.Equal(other.PostDeploymentCommand) {
		return false
	}

	if !v.PostDeploymentCommandContainer.Equal(other.PostDeploymentCommandContainer) {
		return false
	}

	if !v.PreDeploymentCommand.Equal(other.PreDeploymentCommand) {
		return false
	}

	if !v.PreDeploymentCommandContainer.Equal(other.PreDeploymentCommandContainer) {
		return false
	}

	if !v.PreviewUrlTemplate.Equal(other.PreviewUrlTemplate) {
		return false
	}

	if !v.PrivateKeyId.Equal(other.PrivateKeyId) {
		return false
	}

	if !v.PublishDirectory.Equal(other.PublishDirectory) {
		return false
	}

	if !v.Redirect.Equal(other.Redirect) {
		return false
	}

	if !v.RepositoryProjectId.Equal(other.RepositoryProjectId) {
		return false
	}

	if !v.SourceId.Equal(other.SourceId) {
		return false
	}

	if !v.StartCommand.Equal(other.StartCommand) {
		return false
	}

	if !v.StaticImage.Equal(other.StaticImage) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.SwarmPlacementConstraints.Equal(other.SwarmPlacementConstraints) {
		return false
	}

	if !v.SwarmReplicas.Equal(other.SwarmReplicas) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	if !v.WatchPaths.Equal(other.WatchPaths) {
		return false
	}

	return true
}

func (v ApplicationsValue) Type(ctx context.Context) attr.Type {
	return ApplicationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApplicationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"base_directory":                      basetypes.StringType{},
		"build_command":                       basetypes.StringType{},
		"build_pack":                          basetypes.StringType{},
		"compose_parsing_version":             basetypes.StringType{},
		"config_hash":                         basetypes.StringType{},
		"created_at":                          basetypes.StringType{},
		"custom_docker_run_options":           basetypes.StringType{},
		"custom_healthcheck_found":            basetypes.BoolType{},
		"custom_labels":                       basetypes.StringType{},
		"custom_nginx_configuration":          basetypes.StringType{},
		"deleted_at":                          basetypes.StringType{},
		"description":                         basetypes.StringType{},
		"destination_id":                      basetypes.Int64Type{},
		"destination_type":                    basetypes.StringType{},
		"docker_compose":                      basetypes.StringType{},
		"docker_compose_custom_build_command": basetypes.StringType{},
		"docker_compose_custom_start_command": basetypes.StringType{},
		"docker_compose_domains":              basetypes.StringType{},
		"docker_compose_location":             basetypes.StringType{},
		"docker_compose_raw":                  basetypes.StringType{},
		"docker_registry_image_name":          basetypes.StringType{},
		"docker_registry_image_tag":           basetypes.StringType{},
		"dockerfile":                          basetypes.StringType{},
		"dockerfile_location":                 basetypes.StringType{},
		"dockerfile_target_build":             basetypes.StringType{},
		"environment_id":                      basetypes.Int64Type{},
		"fqdn":                                basetypes.StringType{},
		"git_branch":                          basetypes.StringType{},
		"git_commit_sha":                      basetypes.StringType{},
		"git_full_url":                        basetypes.StringType{},
		"git_repository":                      basetypes.StringType{},
		"health_check_enabled":                basetypes.BoolType{},
		"health_check_host":                   basetypes.StringType{},
		"health_check_interval":               basetypes.Int64Type{},
		"health_check_method":                 basetypes.StringType{},
		"health_check_path":                   basetypes.StringType{},
		"health_check_port":                   basetypes.StringType{},
		"health_check_response_text":          basetypes.StringType{},
		"health_check_retries":                basetypes.Int64Type{},
		"health_check_return_code":            basetypes.Int64Type{},
		"health_check_scheme":                 basetypes.StringType{},
		"health_check_start_period":           basetypes.Int64Type{},
		"health_check_timeout":                basetypes.Int64Type{},
		"id":                                  basetypes.Int64Type{},
		"install_command":                     basetypes.StringType{},
		"limits_cpu_shares":                   basetypes.Int64Type{},
		"limits_cpus":                         basetypes.StringType{},
		"limits_cpuset":                       basetypes.StringType{},
		"limits_memory":                       basetypes.StringType{},
		"limits_memory_reservation":           basetypes.StringType{},
		"limits_memory_swap":                  basetypes.StringType{},
		"limits_memory_swappiness":            basetypes.Int64Type{},
		"manual_webhook_secret_bitbucket":     basetypes.StringType{},
		"manual_webhook_secret_gitea":         basetypes.StringType{},
		"manual_webhook_secret_github":        basetypes.StringType{},
		"manual_webhook_secret_gitlab":        basetypes.StringType{},
		"name":                                basetypes.StringType{},
		"ports_exposes":                       basetypes.StringType{},
		"ports_mappings":                      basetypes.StringType{},
		"post_deployment_command":             basetypes.StringType{},
		"post_deployment_command_container":   basetypes.StringType{},
		"pre_deployment_command":              basetypes.StringType{},
		"pre_deployment_command_container":    basetypes.StringType{},
		"preview_url_template":                basetypes.StringType{},
		"private_key_id":                      basetypes.Int64Type{},
		"publish_directory":                   basetypes.StringType{},
		"redirect":                            basetypes.StringType{},
		"repository_project_id":               basetypes.Int64Type{},
		"source_id":                           basetypes.Int64Type{},
		"start_command":                       basetypes.StringType{},
		"static_image":                        basetypes.StringType{},
		"status":                              basetypes.StringType{},
		"swarm_placement_constraints":         basetypes.StringType{},
		"swarm_replicas":                      basetypes.Int64Type{},
		"updated_at":                          basetypes.StringType{},
		"uuid":                                basetypes.StringType{},
		"watch_paths":                         basetypes.StringType{},
	}
}
